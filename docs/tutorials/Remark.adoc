= AddressBook Level 3.5 - Tutorial
:site-section: Tutorial
:toc:
:toc-title:
:toc-placement: preamble
:imagesDir: images/remark
:stylesDir: ../stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]


== Adding your first command

In this tutorial, we'll walk you through the implementation of a new command -- `remark`.

This command allows users of the AddressBook application to add optional remarks to people in their address book and
edit it if required. The command should have the format of `remark INDEX r/REMARK`. An example of the command is
`remark 2 r/Likes baseball`.

We'll assume that you have already set up the development environment as outlined in the Developer's Guide.

=== Create a new `Command`

Looking in the `logic.command` package, you will notice that each existing command have their own class. All the
commands implement `Command` which means that they must override `execute()`. By convention, `Command` returns an
instance of `CommandResult` upon success and throws a `CommandException` otherwise. This exception is handled
gracefully and the error message provided to `CommandException` is printed the application.

Let's start by creating a new `RemarkCommand` class in the `src/main/java/seedu/address/logic/command` directory.


For now, let's keep `RemarkCommand` as simple as possible and return a message that it is not fully implemented yet. We
accomplish that by throwing a `CommandException` with an accompanying error message.

Check out the code for the `RemarkCommand`
link:++https://github.com/j-lum/addressbook-level35/commit/72256eacea79dfcf077f5c7cb6f89819c02f090e#diff
-34ace715a8a8d2e5a66e71289f017b47++[here].

=== Hook `RemarkCommand` into the application

Now that we have our `RemarkCommand` ready to be executed, we need to update `AddressBookParser#parseCommand()` to
recognize the `remark` keyword. Add the new command to the switch-case and return a new instance of `RemarkCommand`.

You can refer to the changes in this
link:++https://github.com/j-lum/addressbook-level35/commit/72256eacea79dfcf077f5c7cb6f89819c02f090e#diff
-5338391f3f6fbb4022c44add6590b74f++[diff].

=== Run the application

Run `Main#main` and try out your new `RemarkCommand`. If everything went well, you should see something like this:

.Successful failure
image::RemarkNotImplemented.png[]

== Enhancing `RemarkCommand`

While we have gotten AddressBook to recognize our new command, it does not parse input any input from the user. Let's
 change that.

=== Make the command accept parameters

We start by modifying the constructor of `RemarkCommand` to accept an `Index` and a `String`. While we are at it,
let's change the error message to echo the values. While this is not a replacement for tests, it is an obvious way to
 tell if our code is functioning as intended.

Your code should look something like
link:++https://github.com/j-lum/addressbook-level35/commit/c0f8419be4fb59bffafcd73026769459e5cf5c5e#diff
-34ace715a8a8d2e5a66e71289f017b47++[this] after you are done.

=== Parse user input

Now let's move on to writing a parser that will extract the index and remark from the input provided by the user.

Create a `RemarkCommandParser` class in the `seedu.address.logic.parser` package. The class must extend the `Parser`
interface.

Thankfully, `ArgumentTokenizer#tokenize()` makes it trivial to parse user input. We can now use the information
extracted from user input to instantiate a new instance of `RemarkCommand`.

NOTE: Don't forget to update `AddressBookParser` to use our new `RemarkCommandParser`!

If you are stuck, check out the sample
link:++https://github.com/j-lum/addressbook-level35/commit/c0f8419be4fb59bffafcd73026769459e5cf5c5e#diff
-fc19ecee89c3732a62fbc8c840250508++[here].

== Adding to the model

Now that we have all the information that we need, let's lay the groundwork for some _persistent_ changes. We acheive
 that by working with the `Person` model. Each field in a Person is encapsulated. This protects them from illegal
 access and allows us to tightly couple logic specific to the field.

=== Add a new `Remark` class

Create a new `Remark` in `seedu.address.model.person`. Since a `Remark` is a field that is similar to `Address`, we
can reuse a significant bit of code.

A quick copy-paste and search-replace later, you should have something like
link:++https://github.com/j-lum/addressbook-level35/commit/c8e6048f0d81f2b4b7797e838226da823892129b#diff
-af2f075d24dfcd333876f0fbce321f25++[this].

=== Make use of `Remark`

Let's change `RemarkCommand` and `RemarkCommandParser` to use the new `Remark` class instead of plain `String`.
These should be relatively simple changes.

== Adding placeholder elements to the UI

Without getting too deep into `fxml`, let's go on a 5 minute adventure to get some placeholder text to show up for
each person.

Simply add
```
@FXML
private Label remark;
```
to
link:++https://github.com/j-lum/addressbook-level35/commit/06f9897d7088d22689de478c94612f8bcbff2964#diff
-0c6b6abcfac8c205e075294f25e851fe++[`PersonCard`]. `@FXML` is an annotation that marks a private or protected field and
 makes it accessible to FXML
. It
 it sounds like Greek to you right now, don't worry -- we will get back to it later.

Then insert

```
<Label fx:id="remark" styleClass="cell_small_label" text="\$remark" />
```
into
link:++https://github.com/j-lum/addressbook-level35/commit/06f9897d7088d22689de478c94612f8bcbff2964#diff
-12580431f55d7880578aa4c16f249e71++[`PersonListCard.fxml`].

That's it! Fire up the application again and you should see something like this:

.Nothing $remark-able
image::$Remark.png[]

NOTE: AddressBook level 3.5 does not require UI tests!

== Updating the model

Since `PersonCard` displays data from a `Person`, we need to update `Person` to get our `Remark` displayed!

=== Modify `Person`

We change the constructor of `Person` to take a `Remark`. We will also need to define new fields accordingly to store
 our new addition.

=== Update other usages of `Person`

Unfortunately, a change to `Person` will cause other commands to break, let's fix these commands to use the updated
`Person`!

== Updating Storage

AddressBook stores data by serializing `JsonAdaptedPerson` into `json` with the help of an external library --
Jackson. Let's update `JsonAdaptedPerson` to work with our new `Person`!

While the changes to code may be minimal, the test data will have to be updated as well.

Check out
link:++https://github.com/j-lum/addressbook-level35/commit/78b2a7438a9f9d828b7f09e190ff6130790966c0++[this commit]
to see what the changes entail.

== Finalizing the UI

Now that we have finalized the `Person` class and its dependencies, we can now bind the `Remark` field to the UI.

Just change
link:++https://github.com/j-lum/addressbook-level35/commit/2edaf1c52e07e28dc7a49742bc63352813a55af9++[this one
 line of code!]

.The remark label is bound properly!
image::RemarkBound.png[]

== Putting everything together

After the previous step, we notice a peculiar regression -- we went from displaying something to nothing at all.
However, this is expected behavior as we have never changed `Remark` at all!

=== Change `Remark`

In this last step, we modify `RemarkCommand#execute()` to change the `Remark` of a `Person`. Since all fields in a
`Person` are immutable, we create a new instance of a `Person` with the values that we want and commit it back to the
 model with `Model#setPerson()`.

After writing the very last set of test, you are now ready to test `RemarkCommand`!

.Congratulations!
image::RemarkComplete.png[]

== Writing tests

Tests are crucial to ensuring that bugs don't slip into the codebase unnoticed. This is especially true for large
code bases where a change might lead to unintended behavior.

Let's verify the correctness of our code by writing some tests!

=== Automagically generating tests

The goal is to write effective and efficient tests to ensure that `RemarkCommand#execute()` behaves as expected.

The convention for test names is _``methodName_testScenario_expectedResult``_. An example would be
`execute_filteredList_success`.

Let's create a test for `RemarkCommand#execute()` to test that adding a remark works. On `IntelliJ IDEA`
you can bring up the context menu and choose to `Go To` > `Test` or use the appropriate keyboard
shortcut.

.Using the context menu to jump to tests
image::ContextMenu.png[, 1223px, 267px]

Then, create a test for the `execute` method.

.Creating a test for `execute`.
image::CreateTest.png[, 664px,751px]

Following convention, let's change the name of the generated method to `execute_addRemarkUnfilteredList_success`.

Let's use the utility functions provided in `CommandTestUtil`. The functions ensure that commands produce the
expected `CommandResult` and output the correct message. In this case, `CommandTestUtil#assertCommandSuccess` is the
best fit as we are testing that a `RemarkCommand` will successfully add a `Remark`.

You should end up with a test that looks something like
link:++https://github.com/j-lum/addressbook-level35/commit/1492fb0d4e8a075f2481028377e0d113e7c01b76#diff
-d749de38392f7ea504da7824641ba8d9++[this].

== Conclusion

This concludes the tutorial for adding a new `Command` to AddressBook.

//Link to more discussions


