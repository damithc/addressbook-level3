= AddressBook Level 3.5 - Tutorial
:site-section: Tutorial
:toc:
:toc-title:
:toc-placement: preamble
:imagesDir: images/remark
:stylesDir: ../stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]


== Implementing your first feature

Let's get started!

In this tutorial, we'll walk you through the implementation of a new command -- `remark`.
This command allows users of the AddressBook application to add optional remarks to people in their address book and
edit it if required.

We'll assume that you have already set up the development environment as outlined in the Developer's Guide.

TIP: If you ever get stuck on the tutorial, head over to the forum!


=== Create a new `Command`

Let's start by creating a new `RemarkCommand` class in the `src/main/java/seedu/address/logic/command` directory.
All commands in AddressBook must implement the `Command` interface.

For now, let's just make `RemarkCommand` return a message that it is not fully implemented yet. We accomplish
that by throwing a `CommandException` with an accompanying error message.

Check out the code for the `RemarkCommand`
link:++https://github.com/j-lum/addressbook-level35/commit/72256eacea79dfcf077f5c7cb6f89819c02f090e#diff
-34ace715a8a8d2e5a66e71289f017b47++[here].

=== Hook `RemarkCommand` into the application

Now that we have our `RemarkCommand` ready to be executed, we need to update `AddressBookParser#parseCommand()` to
recognize the `remark` keyword. Add the new command to the switch-case and return a new instance of `RemarkCommand`.

You can refer to the changes in this
link:++https://github.com/j-lum/addressbook-level35/commit/72256eacea79dfcf077f5c7cb6f89819c02f090e#diff
-5338391f3f6fbb4022c44add6590b74f++[diff].


=== Write tests

NOTE: While testing is extremely important, you can choose to postpone writing tests _for this tutorial_.

On `IntelliJ IDEA` you can bring up the context menu and choose to Go To > Test or use the appropriate keyboard
shortcut.

.Using the context menu to jump to tests
image::ContextMenu.png[]

Next, create a test for the `execute` method.

.Creating a test for `execute`.
image::CreateTest.png[]

We assert that `RemarkCommand` fails as expected using the helpful utility function
`CommandTestUtil#assertCommandFailure`.

TIP: You can use the `Search for target by name` feature in IntelliJ IDEA to look for classes by their name. A quick
way to bring up the dialog is to hit the `shift` key twice.

Since we made modifications to the `AddressBookParser`, we need to write tests for it as well. A simple test that
ensures that the `remark` keyword is parsed correctly will suffice.

The completed tests should look something like
link:++https://github.com/j-lum/addressbook-level35/commit/72256eacea79dfcf077f5c7cb6f89819c02f090e#diff
-d749de38392f7ea504da7824641ba8d9++[this].

=== Build the project

Let's use _gradle_ to build our project. You can either use the terminal (`gradlew <tasks...> `) or define a run
configuration in IntelliJ IDEA.

.Using the gradle toolbar to define a task.
image::GradleRun.png[]

We run the `clean` task to remove any leftovers from previous builds and then `check` to run both our tests and
`checkstyle` tasks.

If the build is successful, you can now run the application and check that the `remark` keyword fails gracefully as
expected!

.Successful failure
image::RemarkNotImplemented.png[]

== Enhancing `RemarkCommand`

While we have gotten AddressBook to recognize our new command, it does not parse input any input from the user. Let's
 change that.

=== Make the command accept parameters

We start by modifying the constructor of `RemarkCommand` to accept an `Index` and a `String`. While we are at it,
let's change the error message to echo the values. While this is not a replacement for tests, it is an obvious way to
 tell if our code is functioning as intended.

Your code should look something like
link:++https://github.com/j-lum/addressbook-level35/commit/c0f8419be4fb59bffafcd73026769459e5cf5c5e#diff
-34ace715a8a8d2e5a66e71289f017b47++[this] after you are done.

=== Parse user input

Now let's move on to writing a parser that will extract the index and remark from the input provided by the user.

Create a `RemarkCommandParser` class in the `seedu.address.logic.parser` package. The class must extend the `Parser`
interface.

Thankfully, `ArgumentTokenizer#tokenize()` makes it trivial to parse user input. We can now use the information
extracted from user input to instantiate a new instance of `RemarkCommand`.

NOTE: Don't forget to update `AddressBookParser` to use our new `RemarkCommandParser`!

If you are stuck, check out the sample
link:++https://github.com/j-lum/addressbook-level35/commit/c0f8419be4fb59bffafcd73026769459e5cf5c5e#diff
-fc19ecee89c3732a62fbc8c840250508++[here].

=== Write more tests

We suggest writing the following tests to verify that the new features are working as intended.

- Equality checks for `RemarkCommand` are correct
- `RemarkCommand` fails with the new message when executed
- `AddressBookParser` returns a `RemarkCommand` with correct input
- `RemarkCommandParser` parses both valid and invalid input correctly

If all the
link:++https://github.com/j-lum/addressbook-level35/commit/c0f8419be4fb59bffafcd73026769459e5cf5c5e#diff
-d749de38392f7ea504da7824641ba8d9++[tests] pass, try running the application again! With any luck, you should see
something like this:

.Fails successfully and verbosely
image::RemarkFailureOutput.png[]

== Adding to the model

Now that we have all the information that we need, let's lay the groundwork for some _persistent_ changes. We acheive
 that by working with the `Person` model.

=== Add a new `Remark` class

Create a new `Remark` in `seedu.address.model.person`. Since a `Remark` is a field that is similar to `Address`, we
can reuse a significant bit of code.

A quick copy-paste and search-replace later, you should have something like
link:++https://github.com/j-lum/addressbook-level35/commit/c8e6048f0d81f2b4b7797e838226da823892129b#diff
-af2f075d24dfcd333876f0fbce321f25++[this].

=== Make use of `Remark`

Let's change `RemarkCommand` and `RemarkCommandParser` to use the new `Remark` class instead of plain `String`.
These should be relatively simple changes.

=== Write even more tests

Update tests for `AddressBookParser`, `RemarkCommandParser` and `RemarkCommand` to use the new `Remark` class instead.

Write tests to ensure that `Remark` works as intended.

Check out some of the suggested
link:++https://github.com/j-lum/addressbook-level35/commit/c8e6048f0d81f2b4b7797e838226da823892129b#diff
-d749de38392f7ea504da7824641ba8d9++[tests].

== Adding placeholder elements to the UI

Without getting too deep into `fxml`, let's go on a 5 minute adventure to get some placeholder text to show up for
each person.

Simply add
```
@FXML
private Label remark;
```
to
link:++https://github.com/j-lum/addressbook-level35/commit/06f9897d7088d22689de478c94612f8bcbff2964#diff
-0c6b6abcfac8c205e075294f25e851fe++[`PersonCard`]. `@FXML` is an annotation that marks a private or protected field and
 makes it accessible to FXML
. It
 it sounds like Greek to you right now, don't worry -- we will get back to it later.

Then insert

```
<Label fx:id="remark" styleClass="cell_small_label" text="\$remark" />
```
into
link:++https://github.com/j-lum/addressbook-level35/commit/06f9897d7088d22689de478c94612f8bcbff2964#diff
-12580431f55d7880578aa4c16f249e71++[`PersonListCard.fxml`].

That's it! Fire up the application again and you should see something like this:

.Nothing $remark-able
image::$Remark.png[]

NOTE: AddressBook level 3.5 does not require UI tests!

== Updating the model

Since `PersonCard` displays data from a `Person`, we need to update `Person` to get our `Remark` displayed!

=== Modify `Person`

We change the constructor of `Person` to take a `Remark`. We will also need to define new fields accordingly to store
 our new addition.

=== Update other usages of `Person`

Unfortunately, a change to `Person` will cause other commands to break, let's fix these commands to use the updated
`Person`!


=== Write some more tests

It should be habit by now, but everything that is changed requires a new set of tests.

Suggested tests and their implementations can be found
link:++https://github.com/j-lum/addressbook-level35/commit/b03b788d5a462403ea7f4dce9a832b62f729f7c4#diff
-60c0eb4d8d0747d80bbe3be2830985a3++[here].

== Update Storage

AddressBook stores data by serializing `JsonAdaptedPerson` into `json` with the help of an external library --
Jackson. Let's update `JsonAdaptedPerson` to work with our new `Person`!

While the changes to code may be minimal, the test data will have to be updated as well.

Check out
link:++https://github.com/j-lum/addressbook-level35/commit/78b2a7438a9f9d828b7f09e190ff6130790966c0++[this commit]
to see what the changes entail.

== Finalizing the UI

Now that we have finalized the `Person` class and its dependencies, we can now bind the `Remark` field to the UI.

Just change
link:++https://github.com/j-lum/addressbook-level35/commit/2edaf1c52e07e28dc7a49742bc63352813a55af9++[this one
 line of code!]

.The remark label is bound properly!
image::RemarkBound.png[]

== Putting everything together

After the previous step, we notice a peculiar regression -- we went from displaying something to nothing at all.
However, this is expected behavior as we have never changed `Remark` at all!

=== Changing `Remark`

In this last step, we modify `RemarkCommand#execute()` to change the `Remark` of a `Person`. Since all fields in a
`Person` are immutable, we create a new instance of a `Person` with the values that we want and commit it back to the
 model with `Model#setPerson()`.

After writing the very last set of test, you are now ready to test `RemarkCommand`!

.Congratulations!
image::RemarkComplete.png[]


